image: node:12.13 # Should match .nvmrc content

stages:
  #- prepare
  - e2e-tests
  - build
  - deploy

before_script:
  - node --version
  - npm --version
  - ls -alh

# Tests stage

#Tests:
#  before_script:
#    - npm ci
#  tags: [visu-cicd-docker]
#  stage: prepare
#  script:
#    - npm run coverage
#  coverage: /All files[^|]*\|[^|]*\s+([\d\.]+)/
#
#Lint:
#  before_script:
#    - npm ci
#  tags: [visu-cicd-docker]
#  stage: prepare
#  script:
#    - npm run lint

# End-to-end tests using Cypress

cypress:
  stage: e2e-tests
  tags: [visu-cicd-docker]
  image: docker/compose:latest
  services:
    - docker:dind
  variables:
    DOCKER_HOST: "tcp://docker:2375/"
    DOCKER_DRIVER: overlay2
    VISUBACK_COMMIT_ID: "master"
    VISUBACK_IMAGE_NAME: "registry.makina-corpus.net/terralego/visu-back"
    REGISTRY_URL: "registry.makina-corpus.net"
    REGISTRY_USER: ""
    REGISTRY_PASSWD: ""
    DOCKER_IMAGE_CACHE: "/cache/${CI_PROJECT_PATH_SLUG}/docker-images"

  before_script:
    # This is required for bind-mounting $PWD inside visu-front container (running as user node)
    - chown -R 1000:1000 .
    - apk add git
    - git clone https://github.com/Terralego/visu-back.git
    - git -C visu-back reset --hard ${VISUBACK_COMMIT_ID}
    - echo "${REGISTRY_PASSWD}" |docker login -u ${REGISTRY_USER} --password-stdin ${REGISTRY_URL}
    # Restore images from local cache
    - test -d "${DOCKER_IMAGE_CACHE}" && find "${DOCKER_IMAGE_CACHE}" -name "*.tar" -exec docker image load -i {} \; || true

  script:
    # Configure node app through env.json and settings.json file
    - sed "s#<BACKEND_URL>#http://nginx/api#"
        <public/env.dist.json |tee public/env.json
    - sed 's/"<STYLE_PATH>"//'
        <public/settings.dist.json |tee public/settings.json
    # Configure django app through .env, docker.env and local.py files
    - |
        cat <<EOT >>visu-back/docker.env
        # Storage config
        PYFILES_BACKEND=pyfiles.storages.s3storage.S3Storage
        PYFILES_ACCESS_KEY=${PYFILES_ACCESS_KEY}
        PYFILES_SECRET_KEY=${PYFILES_SECRET_KEY}
        PYFILES_ENDPOINT_URL=${PYFILES_ENDPOINT_URL}
        PYFILES_REGION_NAME=${PYFILES_REGION_NAME}
        PYFILES_BUCKET_NAME=${PYFILES_BUCKET_NAME}
        EOT
    - sed "s#^FRONT_URL=.*#FRONT_URL=visu-front-${CI_PIPELINE_ID}:3000#;
           \$a POSTGRES_STARTUP_TIMEOUT=300s"
        <visu-back/docker.env.dist |tee visu-back/docker.env
    - sed "s#^DJANGO_IMAGE=.*#DJANGO_IMAGE=${VISUBACK_IMAGE_NAME}#;
           s#^DJANGO_IMAGE_VERSION=.*#DJANGO_IMAGE_VERSION=${VISUBACK_COMMIT_ID}#"
        <visu-back/.env.dist |tee visu-back/.env
    - sed "s#^ALLOWED_HOSTS =.*#ALLOWED_HOSTS = ['nginx']#;
           s#^CORS_ORIGIN_WHITELIST =.*#CORS_ORIGIN_WHITELIST = ('visu-front-${CI_PIPELINE_ID}:3000')#" 
        <visu-back/src/project/settings/local.py.dist |tee visu-back/src/project/settings/local.py
    # Run visu-back stack
    # Note: we explicitly run a docker-compose pull first to fetch visu-back
    # image so that docker-compose doesn't try to build it (because of the
    # `build:` instruction set inside the main docker-compose.yml file)
    - docker-compose -p visu-back-${CI_PIPELINE_ID} --env-file visu-back/.env
        -f visu-back/docker-compose.yml -f visu-back/docker-compose-prod.yml
        pull
    - docker-compose -p visu-back-${CI_PIPELINE_ID} --env-file visu-back/.env 
        -f visu-back/docker-compose.yml -f visu-back/docker-compose-prod.yml 
        up --detach --no-build
    - docker-compose -p visu-back-${CI_PIPELINE_ID} --env-file visu-back/.env 
        -f visu-back/docker-compose.yml -f visu-back/docker-compose-prod.yml 
        exec -T django sh -c "dockerize -wait http://setup-postgres -timeout 120s /code/venv/bin/python manage.py migrate"
    - docker-compose -p visu-back-${CI_PIPELINE_ID} --env-file visu-back/.env 
        -f visu-back/docker-compose.yml -f visu-back/docker-compose-prod.yml 
        exec -T django sh -c "dockerize -wait http://setup-postgres -timeout 120s /code/venv/bin/python manage.py populatedata --test-data"
    # Run visu-front app
    - docker run 
        --name visu-front-${CI_PIPELINE_ID} 
        --network visu-back-${CI_PIPELINE_ID}_default 
        --user node --workdir /home/node/ 
        --expose 3000 
        --volume $PWD/:/home/node/ 
        --detach 
        node:12.13 sh -c "npm ci && npm start"
    # Run Cypress
    # Note: the curl's here as a poor man's Docker wait-for-xxx.sh. We call
    # cypress once visu-front has finished its startup. Cypress already does
    # that but with too short timeout, which make it randomly fails.
    - docker run 
        --name cypress-${CI_PIPELINE_ID} 
        --network visu-back-${CI_PIPELINE_ID}_default 
        --user node --workdir /home/node/ 
        --env CYPRESS_BASE_URL=http://visu-front-${CI_PIPELINE_ID}:3000/ 
        --volume $PWD/package.json:/home/node/package.json 
        --volume $PWD/package-lock.json:/home/node/package-lock.json 
        --volume $PWD/cypress/:/home/node/cypress/ 
        --volume $PWD/cypress.json:/home/node/cypress.json 
        cypress/browsers sh -c "npm ci && curl --silent --show-error --retry 20 --retry-delay 1 --retry-max-time 4 \$CYPRESS_BASE_URL >/dev/null && npm run cypress:run -- --browser chrome"

  after_script:
    # Display logs in case of failure
    - docker-compose -p visu-back-${CI_PIPELINE_ID} --env-file visu-back/.env 
        -f visu-back/docker-compose.yml -f visu-back/docker-compose-prod.yml 
        logs &>visu-back.log || true
    - docker logs visu-front-${CI_PIPELINE_ID} &>visu-front.log || true
    # Save images to local cache
    - mkdir -p "${DOCKER_IMAGE_CACHE}"
    - rm -rf "${DOCKER_IMAGE_CACHE}/*.tar"
    - for img in $(docker image ls -q); do
          echo "${img}";
          docker image save -o "${DOCKER_IMAGE_CACHE}/${img}.tar" "${img}";
      done
    # Cleanup: stop and purge everything
    - docker rm -f visu-front-${CI_PIPELINE_ID} || true
    - docker rm -f cypress-${CI_PIPELINE_ID} || true
    - docker-compose -p visu-back-${CI_PIPELINE_ID} --env-file visu-back/.env 
        -f visu-back/docker-compose.yml -f visu-back/docker-compose-prod.yml 
        down --rmi all --volumes --remove-orphans || true

  artifacts:
    paths:
      - cypress/videos/
      - cypress/screenshots/
      - visu-back.log
      - visu-front.log
    expire_in: 3 days
    when: always

# Deploy story book

Build:
  before_script:
    - npm ci
  tags: [visu-cicd-docker]
  stage: build
  script:
    - npm run build
  artifacts:
    expire_in: 3 days
    paths:
      - build/

.deploy: &deploy # Deploy template
  tags: [visu-cicd-docker]
  stage: deploy
  when: manual
  variables:
    SITE_ID: "yournamehere.netlify.com"
    BACKEND_URL: "yourbackend.makina.com"
    ADMIN_HOST: "https:\\/\\/terra-admin-dev.netlify.com\\/"
  dependencies:
    - Build
  script:
    - cat ./build/env.dist.json | sed
      -e "s/<BACKEND_URL>/${BACKEND_URL}/g" > ./build/env.json
    - cat ./build/env.json
    - cat ./_redirects.dist | sed
      -e "s/<ADMIN_HOST>/${ADMIN_HOST}/g" | sed
      -e "s/<BACKEND_URL>/${BACKEND_URL}/g" > ./build/_redirects
    - npm i -g netlify-cli
    - npx netlify deploy --site=$SITE_ID --auth=$NETLIFY_ACCESS_TOKEN  --dir=./build --prod

Deploy Dev (force): &deploy_predev
  <<: *deploy
  environment:
    name: dev
    url: https://terravisu-demo.netlify.com
  variables:
    SITE_ID: "terravisu-demo.netlify.com"
    BACKEND_URL: "https:\\/\\/terravisu-demo.makina-corpus.net\\/"
    ADMIN_HOST: "https:\\/\\/terra-admin-dev.netlify.com\\/"

Deploy Dev:
  <<: *deploy_predev
  only:
    - master
  when: always
